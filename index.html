<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Carpenter Photo Segregator</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 20px;
            background-color: #f4f7f6;
            color: #333;
        }

        h1, h2 {
            color: #2c3e50;
            text-align: center;
            margin-bottom: 1.5em; /* More space below headings */
        }

        #app-container {
            max-width: 600px;
            margin: 20px auto;
            padding: 25px;
            background-color: #ffffff;
            border-radius: 8px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1); /* Slightly stronger shadow */
        }

        #auth-section, #app-section > div, #app-section > p, #app-section > hr {
            margin-bottom: 20px;
        }

        #auth-section {
            text-align: center;
        }

        hr {
            border: none;
            border-top: 1px solid #eee;
        }

        label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
            color: #555;
        }

        select, input[type="text"], input[type="search"] {
            width: calc(100% - 22px); /* Adjust for padding */
            padding: 10px;
            margin-bottom: 10px;
            border: 1px solid #ccc;
            border-radius: 4px;
            box-sizing: border-box;
        }

        /* Input focus styles */
        select:focus,
        input[type="text"]:focus,
        input[type="search"]:focus {
            outline: none;
            border-color: #3498db;
            box-shadow: 0 0 0 2px rgba(52, 152, 219, 0.2);
        }

        button {
            padding: 10px 18px;
            margin: 5px 5px 5px 0;
            cursor: pointer;
            border: none;
            border-radius: 4px;
            background-color: #3498db; /* Primary blue */
            color: white;
            font-size: 1em;
            transition: background-color 0.2s ease, transform 0.1s ease;
        }

        button:active {
            transform: scale(0.98); /* Slight press effect */
        }

        button:hover {
            background-color: #2980b9; /* Darker blue on hover */
        }

        button:disabled {
            background-color: #bdc3c7;
            cursor: not-allowed;
        }

        #signout-button {
            background-color: #e74c3c;
        }

        #signout-button:hover {
            background-color: #c0392b;
        }

        #retake-photo-button {
            background-color: #f39c12; /* Orange color */
        }

        #retake-photo-button:hover {
            background-color: #e67e22; /* Darker orange on hover */
        }

        #clear-selection-button {
            background-color: #e74c3c; /* Red color (match signout) */
        }

        #clear-selection-button:hover {
            background-color: #c0392b; /* Darker red on hover (match signout) */
        }

        .hidden {
            display: none;
        }

        /* Tree View Styles */
        #folders-tree {
            height: 200px;
            overflow-y: auto;
            border: 1px solid #ccc;
            padding: 10px;
            margin-bottom: 10px;
        }
        #folders-tree ul {
            list-style: none;
            padding-left: 20px;
            margin: 0;
        }
        #folders-tree li {
            padding: 3px 0;
            cursor: pointer;
        }
        #folders-tree .folder-name {
            display: inline-block;
            padding: 2px 5px;
            border-radius: 3px;
        }
        #folders-tree .folder-name.selected {
            background-color: #7FB3D5; /* Darker blue background */
            font-weight: bold;
        }
        #folders-tree li:hover > .folder-name {
            /* No hover background */
        }
        #folders-tree .folder-name::before {
            content: 'â–¶ ';
            margin-right: 5px;
            color: #95a5a6;
            font-size: 0.8em;
        }

        /* Capture/Preview Styles */
        #capture-upload-section {
            text-align: center;
            border: 1px dashed #bdc3c7;
            padding: 20px;
            margin-top: 20px;
            background-color: #f8f9f9;
            border-radius: 5px;
        }
        #capture-upload-section p {
            margin-bottom: 15px;
            color: #555;
        }
        #photo-preview { /* Styling for the preview image */
            display: block;
            max-width: 100%;
            max-height: 400px; /* Limit preview height */
            border: 1px solid #ddd;
            margin: 10px auto 20px auto; /* Add margin bottom */
        }

        #thumbnail-container {
            display: flex;
            flex-wrap: wrap; /* Allow thumbnails to wrap */
            gap: 10px; /* Spacing between thumbnails */
            justify-content: center; /* Center thumbnails */
            max-height: 250px; /* Limit container height */
            overflow-y: auto; /* Add scroll if needed */
            margin-bottom: 20px;
            padding: 5px;
            background-color: #eee; /* Light background for the container */
            border: 1px solid #ddd;
            min-height: 80px; /* Ensure some height even when empty */
        }

        .thumbnail-img {
            max-width: 100px; /* Limit thumbnail width */
            max-height: 100px; /* Limit thumbnail height */
            height: auto;
            width: auto;
            border: 1px solid #ccc;
            object-fit: cover; /* Scale image nicely */
        }

        /* Toast Notification Styles */
        #toast-container {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 2000;
            display: flex;
            flex-direction: column-reverse;
            align-items: center;
        }
        .toast-message {
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px 20px;
            border-radius: 20px;
            margin-top: 10px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            opacity: 0;
            transition: opacity 0.5s ease-in-out;
            font-size: 0.9em;
            text-align: center;
            max-width: 80%;
        }
        .toast-message.show {
            opacity: 1;
        }
        .toast-message.error {
            background-color: rgba(231, 76, 60, 0.85);
        }
        .toast-message.success {
            background-color: rgba(46, 204, 113, 0.85);
        }
    </style>
</head>
<body>
    <div id="app-container">
        <h1>Carpenter Photo Segregator</h1>

        <div id="auth-section">
            <button id="auth-button">Sign in with Google</button>
        </div>

        <div id="app-section" class="hidden">
            <!-- Sign out button moved here or handled differently if needed -->
            <div style="text-align: center;"> <button id="signout-button">Sign Out</button> </div>
            <hr>

            <h2>Select or Create a Folder</h2>
            <div id="folder-selection">
                <label for="folders">Choose a folder:</label>
                <input type="search" id="folder-search" placeholder="Search folders...">
                <div id="folders-tree">
                    <p>--Loading folders--</p>
                </div>
                <button id="refresh-folders-button">Refresh Folders</button>
            </div>
            <div id="folder-creation">
                <input type="text" id="new-folder-name" placeholder="Or create a new folder name">
                <button id="create-folder-button">Create Folder</button>
            </div>

            <hr>

            <!-- Section for taking/uploading photo - shown after folder selection -->
            <div id="capture-upload-section" class="hidden">
                <h2>Take Photo</h2>
                <p>Uploading to: <strong id="selected-folder-name-display">(No folder selected)</strong></p>

                <!-- Hidden file input to trigger camera -->
                <input type="file" id="photo-input" accept="image/*" class="hidden" multiple>

                <!-- Visible elements -->
                <div id="capture-controls">
                    <button id="take-photo-button">Select Photos</button>
                </div>

                <div id="preview-controls" class="hidden">
                    <p><span id="file-count-display">0</span> file(s) selected.</p>
                    <div id="thumbnail-container" alt="Selected photo previews"></div> <!-- Container for thumbnails -->
                    <div> <!-- Button container -->
                        <button id="upload-button">Upload Photos</button>
                        <button id="clear-selection-button">Clear Selection</button>
                    </div>
                </div>
            </div>

        </div>

        <!-- Toast Notification Container -->
        <div id="toast-container"></div>
    </div>

    <script>
        // --- All JavaScript goes here ---

        // --- Constants ---
        const CLIENT_ID = '100110295548-0putirgtu0s9tms183trje4cc6ki72ep.apps.googleusercontent.com';
        const DISCOVERY_DOCS = ["https://www.googleapis.com/discovery/v1/apis/drive/v3/rest"];
        const SCOPES = 'https://www.googleapis.com/auth/drive.file https://www.googleapis.com/auth/drive.metadata.readonly';

        // --- DOM Elements ---
        const authButton = document.getElementById('auth-button');
        const signoutButton = document.getElementById('signout-button');
        const authSection = document.getElementById('auth-section');
        const appSection = document.getElementById('app-section');
        const foldersTreeDiv = document.getElementById('folders-tree');
        const refreshFoldersButton = document.getElementById('refresh-folders-button');
        const newFolderInput = document.getElementById('new-folder-name');
        const createFolderButton = document.getElementById('create-folder-button');
        const photoPreview = document.getElementById('photo-preview');
        const folderSearchInput = document.getElementById('folder-search');
        const toastContainer = document.getElementById('toast-container');
        const selectedFolderNameDisplay = document.getElementById('selected-folder-name-display');
        const captureUploadSection = document.getElementById('capture-upload-section');
        const photoInput = document.getElementById('photo-input');
        const takePhotoButton = document.getElementById('take-photo-button');
        const captureControls = document.getElementById('capture-controls');
        const previewControls = document.getElementById('preview-controls');
        const uploadButton = document.getElementById('upload-button');
        const clearSelectionButton = document.getElementById('clear-selection-button');
        const fileCountDisplay = document.getElementById('file-count-display');
        const thumbnailContainer = document.getElementById('thumbnail-container');

        // --- App State ---
        let tokenClient;
        let gapiInited = false;
        let gisInited = false;
        let isAttemptingSilentSignIn = false; // Flag to prevent duplicate sign-in flows
        let selectedFolderId = null;
        let selectedFolderName = null;
        let fullFolderList = [];
        let selectedFiles = null; // Stores the FileList object from input
        let activeObjectURLs = []; // Keep track of created Object URLs for cleanup

        // --- Initialization ---
        function gapiLoaded() {
            console.log("gapiLoaded callback triggered.");
            gapi.load('client', initializeGapiClient);
        }

        async function initializeGapiClient() {
            console.log("Attempting to initialize gapi client...");
            try {
                await gapi.client.init({
                    discoveryDocs: DISCOVERY_DOCS,
                });
                gapiInited = true;
                console.log("GAPI client initialized successfully.");
                maybeEnableAuthButton();
            } catch (err) {
                console.error("Error initializing GAPI client:", err);
                showToast('Error initializing Google API client.', 'error', 5000);
                gapiInited = false;
                maybeEnableAuthButton();
            }
        }

        function gisLoaded() {
            console.log("gisLoaded callback triggered.");
            console.log("Attempting to initialize GIS token client...");
            try {
                tokenClient = google.accounts.oauth2.initTokenClient({
                    client_id: CLIENT_ID,
                    scope: SCOPES,
                    callback: '', // Defined dynamically
                });
                gisInited = true;
                console.log("GIS token client initialized successfully.");
                maybeEnableAuthButton();
            } catch (err) {
                console.error("Error initializing GIS token client:", err);
                showToast('Error initializing Google Identity Services.', 'error', 5000);
                gisInited = false;
                maybeEnableAuthButton();
            }
        }

        function maybeEnableAuthButton() {
            console.log(`Checking if auth button can be enabled: gapiInited=${gapiInited}, gisInited=${gisInited}`);
            if (gapiInited && gisInited) {
                authButton.disabled = false;
                console.log("Auth button enabled.");
                // Attempt silent sign-in only if not already done
                if (!isAttemptingSilentSignIn && gapi.client.getToken() === null) {
                    attemptSilentSignIn();
                }
            } else {
                authButton.disabled = true;
                console.log("Auth button remains disabled.");
            }
        }

        // --- Authentication Functions ---
        async function handleTokenResponse(resp) {
            isAttemptingSilentSignIn = false; // Reset flag
            if (resp.error !== undefined) {
                // Log error for silent failure, show toast for manual failure
                console.warn('Token request error:', resp.error);
                // Only show toast if it wasn't a silent attempt error (which is expected if user isn't logged in)
                if (resp.error !== 'popup_closed' && resp.error !== 'user_cancel' && resp.error !== 'access_denied' && resp.error !== 'immediate_failed') {
                    showToast('Sign-in error: ' + resp.error, 'error', 5000);
                }
                // Do NOT throw error here for silent failures, just don't proceed
                // For manual failures, the user sees the toast.
                return;
            }
            // Successful token acquisition (silent or manual)
            showToast('Sign-in successful!', 'success');
            updateUiSignedIn(true);
            await listFolders();
        }

        // Function to attempt silent sign-in on page load
        function attemptSilentSignIn() {
            if (gapi.client.getToken() !== null) {
                console.log('Already have a token, skipping silent sign-in attempt.');
                return; // Already signed in from this session
            }
            console.log('Attempting silent sign-in...');
            isAttemptingSilentSignIn = true;
            tokenClient.callback = handleTokenResponse; // Use shared handler
            tokenClient.requestAccessToken({ prompt: 'none' });
        }

        function handleAuthClick() {
            if (gapi.client.getToken() === null) {
                // Manual sign-in attempt
                console.log('Manual sign-in initiated...');
                tokenClient.callback = handleTokenResponse; // Use shared handler
                tokenClient.requestAccessToken({ prompt: 'consent' });
            } else {
                // Already signed in, perhaps clicked button again?
                // Could optionally refresh token or just ignore. Let's ignore for now.
                console.log('Manual sign-in clicked, but already signed in.');
            }
        }

        function handleSignoutClick() {
            const token = gapi.client.getToken();
            if (token !== null) {
                google.accounts.oauth2.revoke(token.access_token, () => {
                    gapi.client.setToken(null);
                    updateUiSignedIn(false);
                    showToast('Signed out.');
                    clearFolderTree();
                    selectedFolderId = null;
                    selectedFolderName = null;
                    captureUploadSection.classList.add('hidden');
                    resetPhotoState(); // Reset photo input/preview
                });
            } else {
                showToast('Already signed out.');
            }
        }

        // --- Drive API Functions ---
        async function listFolders() {
            showToast('Loading folders...');
            foldersTreeDiv.innerHTML = '<p>--Loading folders--</p>';
            refreshFoldersButton.disabled = true;
            fullFolderList = [];
            let pageToken = null;
            try {
                do {
                    const response = await gapi.client.drive.files.list({
                        q: "mimeType='application/vnd.google-apps.folder' and trashed=false",
                        fields: 'nextPageToken, files(id, name, parents)',
                        pageSize: 500,
                        pageToken: pageToken,
                        orderBy: 'name'
                    });
                    if (response.result.files) {
                        fullFolderList = fullFolderList.concat(response.result.files);
                    }
                    pageToken = response.result.nextPageToken;
                } while (pageToken);

                const currentSearchTerm = folderSearchInput.value;
                filterAndRenderTree(currentSearchTerm);

                if (fullFolderList.length === 0) {
                    showToast('No folders found.');
                } else {
                     if (!currentSearchTerm) {
                         showToast('Folder tree loaded.', 'success');
                     }
                }
            } catch (err) {
                showToast('Error loading folders.', 'error', 5000);
                foldersTreeDiv.innerHTML = '<p>--Error loading folders--</p>';
            } finally {
                refreshFoldersButton.disabled = false;
            }
        }

        function buildTree(folders) {
            const map = {};
            const roots = [];
            folders.forEach(folder => {
                map[folder.id] = { ...folder, children: [] };
            });
            Object.values(map).forEach(node => {
                if (node.parents && node.parents.length > 0) {
                    const parentId = node.parents[0];
                    if (map[parentId]) {
                        if (!map[parentId].children.some(child => child.id === node.id)) {
                            map[parentId].children.push(node);
                        }
                    } else {
                        if (!roots.some(root => root.id === node.id)) {
                            roots.push(node);
                        }
                    }
                } else {
                    if (!roots.some(root => root.id === node.id)) {
                        roots.push(node);
                    }
                }
            });
            roots.sort((a, b) => a.name.localeCompare(b.name));
            Object.values(map).forEach(node => {
                node.children.sort((a, b) => a.name.localeCompare(b.name));
            });
            return roots;
        }

        function filterTree(nodes, searchTerm) {
            if (!searchTerm) return nodes;
            const lowerSearchTerm = searchTerm.toLowerCase();
            function recursiveFilter(node, parentMatched) {
                const isDirectMatch = node.name.toLowerCase().includes(lowerSearchTerm);
                const shouldIncludeAllChildren = isDirectMatch || parentMatched;
                let filteredChildren = [];
                let hasMatchingDescendant = false;
                if (node.children && node.children.length > 0) {
                    node.children.forEach(child => {
                        const result = recursiveFilter(child, shouldIncludeAllChildren);
                        if (result) {
                            filteredChildren.push(result);
                            hasMatchingDescendant = true;
                        }
                    });
                }
                if (isDirectMatch || hasMatchingDescendant || parentMatched) {
                    return { ...node, children: filteredChildren };
                } else {
                    return null;
                }
            }
            return nodes.map(node => recursiveFilter(node, false)).filter(node => node !== null);
        }

        function filterAndRenderTree(searchTerm) {
            console.log("Filtering tree with term:", searchTerm);
            const fullTree = buildTree(fullFolderList);
            const filteredTreeNodes = filterTree(fullTree, searchTerm);
            renderTree(filteredTreeNodes, foldersTreeDiv);
            if (selectedFolderId) {
                const selectedLi = foldersTreeDiv.querySelector(`li[data-folder-id="${selectedFolderId}"]`);
                if (selectedLi) {
                    const selectedSpan = selectedLi.querySelector('.folder-name');
                    if (selectedSpan) {
                        selectedSpan.classList.add('selected');
                    }
                }
            }
        }

        function renderTree(nodes, container) {
            container.innerHTML = '';
            if (!nodes || nodes.length === 0) {
                container.innerHTML = '<p>No matching folders found.</p>';
                return;
            }
            const ul = document.createElement('ul');
            nodes.forEach(node => {
                const li = document.createElement('li');
                li.dataset.folderId = node.id;
                const span = document.createElement('span');
                span.className = 'folder-name';
                span.textContent = node.name;
                li.appendChild(span);
                li.addEventListener('click', handleFolderSelect);
                if (node.children && node.children.length > 0) {
                    const childUl = document.createElement('ul');
                    renderTree(node.children, childUl);
                    li.appendChild(childUl);
                }
                ul.appendChild(li);
            });
            container.appendChild(ul);
        }

        async function createFolder() {
            const folderName = newFolderInput.value.trim();
            if (!folderName) {
                showToast('Please enter a folder name.', 'error');
                return;
            }
            showToast(`Creating folder "${folderName}"...`);
            createFolderButton.disabled = true;
            newFolderInput.disabled = true;
            try {
                if (!selectedFolderId) {
                    showToast('Please select a parent folder first.', 'error');
                    throw new Error('Parent folder not selected');
                }
                const fileMetadata = {
                    name: folderName,
                    mimeType: 'application/vnd.google-apps.folder',
                    parents: [selectedFolderId]
                };
                const response = await gapi.client.drive.files.create({
                    resource: fileMetadata,
                    fields: 'id, name'
                });
                showToast(`Folder "${response.result.name}" created.`, 'success');
                newFolderInput.value = '';
                await listFolders();
            } catch (err) {
                if (err.message !== 'Parent folder not selected') {
                    showToast('Error creating folder.', 'error');
                    console.error('Error creating folder:', err);
                }
            } finally {
                createFolderButton.disabled = false;
                newFolderInput.disabled = false;
            }
        }

        function handleFolderSelect(event) {
            console.log('[handleFolderSelect] Triggered by click on:', event.target); // Keep this log
            event.stopPropagation();
            let targetLi = event.target;
            while (targetLi && targetLi.tagName !== 'LI') {
                targetLi = targetLi.parentElement;
            }
            if (!targetLi || !targetLi.dataset.folderId) return;

            const newFolderId = targetLi.dataset.folderId;
            const newFolderName = targetLi.querySelector('.folder-name').textContent;

            // Re-add detailed log BEFORE the check
            console.log(`[handleFolderSelect] Comparing new ID: ${newFolderId} with current selected ID: ${selectedFolderId}`);

            // Check if the selection is actually changing
            const isNewSelection = newFolderId !== selectedFolderId;

            // Update highlighting regardless of whether the folder changed
            const currentlySelectedSpan = foldersTreeDiv.querySelector('.folder-name.selected');
            if (currentlySelectedSpan) {
                currentlySelectedSpan.classList.remove('selected');
            }
            const targetSpan = targetLi.querySelector('.folder-name');
            if (targetSpan) {
                targetSpan.classList.add('selected');
            }

            // Update state and UI only if it is a new selection
            if (isNewSelection) {
                console.log(`Folder selection changed: ${newFolderName} (${newFolderId})`); // Optional log
                selectedFolderId = newFolderId;
                selectedFolderName = newFolderName;
                selectedFolderNameDisplay.textContent = newFolderName;
                captureUploadSection.classList.remove('hidden');
                resetPhotoState(); // Reset photo state ONLY when folder selection changes
            } else {
                console.log(`Re-clicked same folder: ${newFolderName} (${newFolderId})`); // Optional log
                // Ensure capture section is visible even if same folder is re-clicked
                captureUploadSection.classList.remove('hidden');
            }
        }

        function clearFolderTree() {
            foldersTreeDiv.innerHTML = '<p>--Select a folder--</p>';
        }

        // --- Photo Input/Preview Functions ---
        function handleTakePhotoClick(event) {
            event.stopPropagation();
            photoInput.click();
        }

        function handleFileInputChange(event) {
            console.log('[handleFileInputChange] Event triggered!');
            try {
                console.log('[handleFileInputChange] Inside try block...');
                if (event.target.files && event.target.files.length > 0) {
                    console.log('[handleFileInputChange] Found files:', event.target.files.length); // Log success
                    const filesFromInput = event.target.files; // Get the FileList
                    console.log('[handleFileInputChange] Got FileList:', filesFromInput);

                    // Copy files to a new array BEFORE resetting input
                    const filesArray = [];
                    for (let i = 0; i < filesFromInput.length; i++) {
                        filesArray.push(filesFromInput[i]);
                    }
                    selectedFiles = filesArray; // Assign the copied array to global state
                    console.log('[handleFileInputChange] Copied to array, selectedFiles:', selectedFiles);

                    // Now reset the input value - this should NOT affect the copied array
                    event.target.value = null;
                    console.log('[handleFileInputChange] Input value reset. Checking selectedFiles again:', selectedFiles);

                    // Proceed using the selectedFiles array
                    thumbnailContainer.innerHTML = '';
                    revokeActiveObjectURLs();

                    // Create and display thumbnails
                    for (const file of selectedFiles) {
                        const img = document.createElement('img');
                        const objectURL = URL.createObjectURL(file);
                        img.src = objectURL;
                        img.className = 'thumbnail-img';
                        img.alt = file.name;
                        thumbnailContainer.appendChild(img);
                        activeObjectURLs.push(objectURL); // Store URL for later revocation
                    }
                    console.log('[handleFileInputChange] Accessing fileCountDisplay...', fileCountDisplay);
                    fileCountDisplay.textContent = selectedFiles.length;
                    console.log('[handleFileInputChange] Accessing captureControls/previewControls...', captureControls, previewControls);
                    captureControls.classList.add('hidden');
                    previewControls.classList.remove('hidden');

                    showToast(`${selectedFiles.length} photo(s) ready for upload.`, 'info');
                } else {
                    console.log('[handleFileInputChange] No files found in event.target.files or length is 0.');
                    console.log('[handleFileInputChange] event.target.files value was:', event.target.files); // Log the actual value
                    selectedFiles = null;
                    fileCountDisplay.textContent = 0;
                }
            } catch (error) {
                console.error('[handleFileInputChange] Error during file processing:', error);
                showToast('Error processing selected photos.', 'error');
                resetPhotoState(); // Reset state on error
            }
        }

        function handleClearSelectionClick(event) {
            event.stopPropagation();
            resetPhotoState();
            showToast('Selection cleared. Ready to select new photos.');
        }

        function resetPhotoState() {
            console.log('[resetPhotoState] Called. Resetting selectedFiles.'); // Re-add log
            selectedFiles = null;
            photoInput.value = null;
            thumbnailContainer.innerHTML = ''; // Clear thumbnails
            revokeActiveObjectURLs(); // Revoke any active URLs
            fileCountDisplay.textContent = 0;
            captureControls.classList.remove('hidden');
            previewControls.classList.add('hidden');
            uploadButton.disabled = false;
            clearSelectionButton.disabled = false;
        }

        // Helper function to revoke object URLs
        function revokeActiveObjectURLs() {
            activeObjectURLs.forEach(url => URL.revokeObjectURL(url));
            activeObjectURLs = []; // Reset the array
        }

        // --- Upload Function (Modified for multiple files) ---
        async function handleUploadClick(event) {
            event.stopPropagation();
            console.log('[handleUploadClick] Started. Checking selectedFiles value:', selectedFiles); // Re-add log
            if (!selectedFiles || selectedFiles.length === 0) {
                showToast('No photo selected yet.', 'error');
                return;
            }
            if (!selectedFolderId) {
                showToast('No folder selected for upload.', 'error');
                return;
            }

            const totalFiles = selectedFiles.length;
            showToast(`Starting upload of ${totalFiles} photo(s)...`, 'info');
            uploadButton.disabled = true;
            clearSelectionButton.disabled = true;

            let successCount = 0;
            let errorCount = 0;
            const uploadPromises = [];

            // Get token once for all uploads
            const accessToken = gapi.client.getToken()?.access_token;
            if (!accessToken) {
                showToast('Authentication error. Please sign in again.', 'error');
                uploadButton.disabled = false;
                clearSelectionButton.disabled = false;
                return;
            }

            // Create an upload promise for each file
            for (const file of selectedFiles) {
                uploadPromises.push(uploadSingleFile(file, selectedFolderId, accessToken));
            }

            // Wait for all upload attempts to settle
            const results = await Promise.allSettled(uploadPromises);

            // Process results
            results.forEach(result => {
                if (result.status === 'fulfilled') {
                    successCount++;
                } else {
                    errorCount++;
                    console.error('Individual upload failed:', result.reason);
                }
            });

            // Final status message
            if (errorCount === 0) {
                showToast(`${successCount} photo(s) uploaded successfully!`, 'success');
                resetPhotoState(); // Reset UI only if all succeed
            } else {
                showToast(`${successCount} succeeded, ${errorCount} failed. Check console for details.`, 'error', 5000);
                // Re-enable buttons on partial/full failure
                uploadButton.disabled = false;
                clearSelectionButton.disabled = false;
            }

            // Always revoke URLs after upload attempt, regardless of success/failure
            revokeActiveObjectURLs();
        }

        // Helper function to upload a single file
        async function uploadSingleFile(file, parentFolderId, accessToken) {
            console.log(`Uploading file: ${file.name} to folder: ${parentFolderId}`);
            try {
                const filename = file.name || `photo_${new Date().toISOString().replace(/:/g, '_').replace(/\.\d{3}Z$/, 'Z')}.jpg`;
                const metadata = {
                    name: filename,
                    mimeType: file.type || 'image/jpeg',
                    parents: [parentFolderId]
                };
                console.log('Upload metadata:', metadata);
                const form = new FormData();
                form.append('metadata', new Blob([JSON.stringify(metadata)], { type: 'application/json' }));
                form.append('file', file);

                const fetchResponse = await fetch('https://www.googleapis.com/upload/drive/v3/files?uploadType=multipart', {
                    method: 'POST',
                    headers: { 'Authorization': `Bearer ${accessToken}` },
                    body: form
                });
                const responseJson = await fetchResponse.json();
                if (!fetchResponse.ok) {
                    throw new Error(`Upload failed: ${fetchResponse.status} ${fetchResponse.statusText} - ${JSON.stringify(responseJson)}`);
                }
                console.log('Upload successful! API Response:', responseJson);
                return responseJson;
            } catch (err) {
                console.error(`Failed to upload ${file.name}:`, err);
                throw err;
            }
        }

        // --- UI Update Functions ---
        function updateUiSignedIn(isSignedIn) {
            if (isSignedIn) {
                authSection.classList.add('hidden');
                appSection.classList.remove('hidden');
            } else {
                authSection.classList.remove('hidden');
                appSection.classList.add('hidden');
                clearFolderTree();
                selectedFolderId = null;
                selectedFolderName = null;
                captureUploadSection.classList.add('hidden');
                resetPhotoState();
            }
        }

        function showToast(message, type = 'info', duration = 3000) {
            const toast = document.createElement('div');
            toast.className = `toast-message ${type}`;
            toast.textContent = message;
            toastContainer.appendChild(toast);
            setTimeout(() => {
                toast.classList.add('show');
            }, 10);
            setTimeout(() => {
                toast.classList.remove('show');
                toast.addEventListener('transitionend', () => {
                    if (toast.parentNode) {
                        toast.parentNode.removeChild(toast);
                    }
                });
            }, duration);
        }

        // --- Event Listeners ---
        authButton.addEventListener('click', handleAuthClick);
        signoutButton.addEventListener('click', handleSignoutClick);
        refreshFoldersButton.addEventListener('click', listFolders);
        createFolderButton.addEventListener('click', createFolder);
        takePhotoButton.addEventListener('click', handleTakePhotoClick);
        photoInput.addEventListener('change', handleFileInputChange);
        clearSelectionButton.addEventListener('click', handleClearSelectionClick);
        uploadButton.addEventListener('click', handleUploadClick);
        folderSearchInput.addEventListener('input', (e) => filterAndRenderTree(e.target.value));

        // --- Initial Setup ---
        authButton.disabled = true;

        // Load Google APIs via script tags at end of body

    </script>

    <!-- Google API Client Library -->
    <script src="https://apis.google.com/js/api.js" onload="gapiLoaded()"></script>
    <!-- Google Sign-In (GSI) Client Library -->
    <script src="https://accounts.google.com/gsi/client" onload="gisLoaded()"></script>

</body>
</html>
